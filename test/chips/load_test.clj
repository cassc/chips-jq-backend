(ns chips.load-test
  (:require
   [chips.store.rds :as rds]
   [taoensso.carmine   :as car :refer (wcar)]
   [taoensso.timbre :as t]
   [clojure.core.async :refer [go chan >! <!!]]
   [chips.models.base :refer [->entities mysql-db]]
   [clojure.java.jdbc :as j]
   [chips.utils :refer [dissoc-empty-val]]
   [clojure.string :as s]
   [sparrows.http :refer [async-request]]
   [cheshire.core :as cheshire :refer [parse-string]]
   [clojure.test :refer :all]
   [clj-gatling.core :as gatling]
   [org.httpkit.client :as http]))

;; generated by (doall (repeatedly 10 #(select-keys (rand-nth u) [:company_id :phone :password :sina_blog :qq :weixin])))

(def ^:dynamic *base-url* "https://192.168.0.72/v2")

;; we first get token from gatling context map, if not found, we try
;; to get from tokens-store
(def tokens-store (atom nil))

;; number of concurrent user logins
(def ^:dynamic *n-users* 100)
;; time used to fire all the requests
(def firing-span-secs 10)

(def base-request-map
  {:insecure? true
   :keepalive 30000
   :headers {"user-agent" "load-test-chips"
             "cs-app-id" "ebcad75de0d42a844d98a755644e30"}
   :timeout 10000})

(defn get-token-from-store [{:keys [cs-token user-id] :as context}]
  (or cs-token (nth @tokens-store (mod user-id *n-users*))))

(def now (System/currentTimeMillis))

(let [urls {:base-request ""
            :fetch-roles "/roles"
            :login-request "/account/login"
            :sync-mdata "/mdata"
            :fetch-mdata (str "/mdata?end=" now "&cnt=10&mtype=all")
            :latest-app "/latestapp/15?version=1.1.1&platform=ios&region=china&sdk=9.2"}]
  (defn make-url [key]
    (str *base-url* (key urls))))

(defn fetch-tokens [& [n]]
  (let [tokens (rds/wcar* (car/keys "token:id:*"))]
    (into []
          (comp (take (or n 10))
                (map #(subs % 9)))
          tokens)))

(defn init []
  (reset! tokens-store (fetch-tokens *n-users*)))

;; (defn least-active-users [& [n]]
;;   (let [qstr "select email,phone,password,last_login,days,weight_unit,company_id,qq,sina_blog,weixin,grade_id,register_time,length_unit, a.id aid,max(measure_time) measure_time  from csb_account a left join csb_mdata d on a.id=d.account_id where phone>0 group by aid order by measure_time limit ?"]
;;     (j/query (mysql-db) [qstr (or n 10)] :row-fn dissoc-empty-val)))

;; (def memo-users (memoize least-active-users))

(defn non-blank-val? [v]
  (when v
    (let [v (s/trim (str v))]
      (when (and (not (s/blank? v)) (not (= "0" v)))
        v))))

(defn- get-token-from-header [headers]
  (get headers :cs-token))

(defn warm-up
  "Warm up https request"
  []
  @(http/get *base-url* base-request-map))

(defn- default-callback-fn [{:keys [status body error headers] :as resp}]
  (and (= status 200)
       (not= 1 (:code (parse-string body keyword)))
       true))

(defn cds-success
  [{:keys [status body error headers] :as resp}]
  (and (= status 200)
       (= 200 (:code (parse-string body keyword)))
       true))

(defn make-load-requester [{:keys [method url-key form-params callback-fn]
                            :or {callback-fn default-callback-fn}}]
  (fn [{:keys [cs-token user-id] :as context}]
    (try
     (let [response (chan)
           url (make-url url-key)
           options (-> base-request-map
                       (assoc-in [:headers "cs-token"] (get-token-from-store context))
                       (assoc :form-params form-params))]
       (method
        url
        options
        (fn [{:keys [status body error headers] :as resp}]
          (go (let [r (callback-fn resp)]
                (>! response r)
                (when-not r
                  (t/warn (name url-key) "resp:" status error body))))))
       response)
     (catch Throwable e
       (t/error e)))))

(def latest-app
  (make-load-requester {:method http/get
                        :url-key :latest-app}))

(def fetch-mdata
  (make-load-requester {:method http/get
                        :url-key :fetch-mdata}))
(def base-request
  (make-load-requester {:method http/get
                        :url-key :base-request
                        :callback-fn (fn [_] true)}))

(def sync-mdata
  (make-load-requester {:method http/post
                        :url-key :sync-mdata
                        :form-params {:start (- now 2419200000) :end now :lastsync 0 :action "sync"}
                        :callback-fn cds-success}))

(def fetch-roles
  (make-load-requester {:method http/get
                        :url-key :fetch-roles
                        :callback-fn cds-success}))

(defn run-local-test []
  ;; (dorun (memo-users n-users))
  (init)
  (warm-up)
  (gatling/run
    {:name "Simulation"
     :scenarios [#_{:name "Login-scenario"
                  :steps [#_{:name "Login"
                             :request login-request}]}
                 ;; {:name "Base request scenario"
                 ;;  :steps [{:name "base-req"
                 ;;           :request base-request}]}
                 {:name "latestapp-scenario"
                  :steps [{:name "latest-app"
                           :request latest-app}]}
                 {:name "fetch-roles-scenario"
                  :steps [{:name "Fetch-roles"
                           :request fetch-roles}]}
                 {:name "sync-mdata-scenario"
                  :steps [{:name "sync-mdata"
                           :request sync-mdata}]}
                 {:name "fetch-mdata-scenario"
                  :steps [{:name "fetch-mdata"
                           :request fetch-mdata}]}
                 ]}
    {:concurrency *n-users*
     ;; :requests 3
     :root "/tmp"
     :duration (when firing-span-secs (clj-time.core/seconds firing-span-secs))
     :timeout-in-ms 20000}))

(comment
  (binding [*n-users* 100]
    (run-local-test))
  (binding [*n-users* 500
            *base-url* "https://api.leancloud.cn/1.1/login"]
    (run-local-test))
  )

